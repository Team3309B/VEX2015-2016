#pragma config(UART_Usage, UART1, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in8,    backupBattery,  sensorAnalog)
#pragma config(Sensor, dgtl1,  elevatorEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  elevatorBotLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl4,  rightDriveTrain, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  leftDriveTrain, sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  elevatorTopLimitSwitch, sensorTouch)
#pragma config(Sensor, dgtl9,  gyroButton,     sensorTouch)
#pragma config(Sensor, dgtl10, encoderButton,  sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           shooter1,      tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           shooter2,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightDriveExtra, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftDriveExtra, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightDrive,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftDrive,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           shooter4,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           shooter3,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          elevator2,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma systemFile

// Necessary File For Vex Competition
#include "Vex_Competition_Includes.c"

void sendString ( TUARTs uart, char* hello ) {
	for(int i = 0; i < 32; i++) {
		sendChar(uart, hello[i]);
	}
	sendChar(uart, '\r');
	sendChar(uart, '\n');
}

// --- Joystick Functions ---
// Makes the value 0 if it is less than thresh
int threshold( int value, int thresh) {
	if ( abs(value) < thresh) {
		return 0;
	}
	return value;
}

#include "DeclarationsAndDefines.h"
#include "Sensors.c"
// Subsystems
#include "Drive.c"
#include "Intake.c"
#include "Shooter.c"
#include "Elevator.c"
#include "Lift.c"

#include "LCDAuto.c"

#include "Auto.c"
#include "MiscFunctions.c"



// Ran when you turn ON Robot, I opt not to use this
void pre_auton() {
	writeDebugStreamLine("WHY DOESNT IT WRUN?");
}

// Ran in Auto
task autonomous() {
	if(!bSoundActive) {
		playSoundFile("1.wav");
	}
	isAuto = true;
//	startBallTasks();
	// Reset Encoders and then run the begin auto method found in AUTO.c
	resetEn();
	writeDebugStreamLine("AUTO");
	startauton();
	stopDrive();
}

//Ran in Teleop
task usercontrol() {
	isAuto = false;
	nMotorEncoder[shooter1] = 0;
	nMotorEncoder[rightDrive] = 0;
	nMotorEncoder[leftDrive] = 0;
	clearTimer(T2);
	startTask( runLCD );

	writeDebugStreamLine("IT STARTED");

	// Clear Encoders and possibly Gyro
	initSensors();
	resetEn();
	writeDebugStreamLine("ABOUT TO RESET GYRO");

	writeDebugStreamLine("I FINISHED");
	//Start the tasks that control each aspect of the robot
	startTask( driveTask );
	startBallTasks();

	writeDebugStreamLine("IT HAS STARTED");

	while(true) {

		writeDebugStreamLine("pastRight: %4.4f pastLeft: %4.4f pastGyro: %4.4f" , pastRight, pastLeft, pastGyro);

		float delayAmount = 150;
		leftDriveVelocity = (float)(((float)-SensorValue[leftDrive] - pastLeft) / delayAmount); // Divide by "delayAmount" so that if you change the update loop frequency, your velocities don't change
		rightDriveVelocity = (float)(((float)SensorValue[rightDrive] - pastRight) / delayAmount);
		gyroAngularVelocity = (float)(((float)-SensorValue[gyro] - pastGyro) / delayAmount);

		writeDebugStreamLine("LeftError: %4.4f rightError: %4.4f gyroError: %4.4f", ((float)SensorValue[leftDrive] - pastLeft), ((float)-SensorValue[rightDrive] - pastRight),  ((float)-SensorValue[gyro] - pastGyro));
		x += sin((SensorValue[gyro]/10) * (pi/180)) * ((((float)-SensorValue[leftDrive] - pastLeft) + ((float)SensorValue[rightDrive] - pastRight))/2);
		y += cos((SensorValue[gyro]/10) * (pi/180)) * ((((float)-SensorValue[leftDrive] - pastLeft) + ((float)SensorValue[rightDrive] - pastRight))/2);
		writeDebugStreamLine("anglerawcos:%4.4f cos: %4.4f sin: %4.4f h: %4.4f", cos((SensorValue[gyro]/10) * (pi/180)), cos(SensorValue[gyro]/10), sin(SensorValue[gyro]/10),((((float)-SensorValue[leftDrive] - pastLeft) + ((float)SensorValue[rightDrive] - pastRight))/2 ));
		writeDebugStreamLine("x: %i y: %i", x, y);

		pastRight = (float)SensorValue[rightDrive];
		pastLeft = (float)-SensorValue[leftDrive];
		pastGyro = (float)-SensorValue[gyro];

		if( vexRT[Btn7L] && !bSoundActive) {
			playSoundFile("4.wav");
		}
		if(vexRT[Btn8U]) {
			resetGyro();
		}else if(SensorValue(encoderButton)) {
			resetEn();
		}
		wait1Msec(150);
	}
}
